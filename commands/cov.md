# テストカバレッジ改善

テストカバレッジを計測し、@tdd-guidelines に従って不足しているテストを自動生成し、プロジェクト全体のカバレッジ目標（70%以上、ビジネスロジック90%以上）を達成せよ。

---

## 1. 現在のカバレッジを測定する

以下のコマンドでカバレッジレポートを生成：

```bash
npx jest --coverage --silent
```

カバレッジレポートを解析し、以下の情報を抽出する：
- 全体のカバレッジ率（Statements, Branches, Functions, Lines）
- ファイルごとのカバレッジ率
- カバーされていない行番号

## 2. カバレッジ不足ファイルの優先順位付け

カバレッジレポートから以下のパターンでファイルを分類し、@tdd-guidelines の目標に基づいて優先順位を決定：

### ファイル分類の判定基準

各ファイルのパスと名前から以下のパターンマッチングで分類：

**最優先（カバレッジ90%目標）- ビジネスロジック**
- ファイル名が `handler.ts`, `schema.ts`, `service.ts` を含む
- パスに `validation` を含む
- パスに `search` を含み、features配下にある
- ファイル名が `*Handlers.ts`, `*Service.ts` を含む

**高優先度（カバレッジ80%目標）- ユーティリティ・ヘルパー**
- パスに `utils` または `helpers` を含む
- ファイル名が `*Helper.ts`, `*Helpers.ts`, `guards.ts` を含む
- `src/lib/` 配下のファイル

**中優先度（カバレッジ70%目標）- データアクセス層**
- パスに `prisma`, `managers`, `repository`, `repositories` を含む
- ファイル名が `*Manager.ts`, `*Repository.ts` を含む

**低優先度（カバレッジ50%目標、必要に応じて）- インフラ・設定系**
- パスに `oauth`, `auth`, `config` を含む
- ファイル名が `main.ts`, `index.ts`（エントリーポイント）
- パスに `server` を含む

### 優先順位決定アルゴリズム

1. カバレッジレポートからカバレッジ率が目標未達のファイルを抽出
2. 各ファイルを上記パターンで分類
3. 同じ優先度内では、カバレッジ率が低い順にソート
4. 最優先から順にテスト作成を実施

## 3. 各ファイルのテスト作成

カバレッジが目標に達していないファイルに対して、以下の手順でテストを作成：

### 3.1 ファイル内容の分析

対象ファイルを読み込み、以下を特定：
- エクスポートされている関数・クラス
- 各関数の入出力型
- 外部依存（DB、API、ファイルシステム等）
- エッジケース（境界値、エラーケース）

### 3.2 テストファイルの作成・更新

`__tests__/` ディレクトリに `{対象ファイル名}.test.ts` を作成または更新：

**テストファイルテンプレート：**

```typescript
/**
 * {対象ファイル名} のテスト
 */

import { 対象関数 } from '../対象ファイル';

describe('{モジュール名またはクラス名}', () => {
  describe('{関数名}', () => {
    it('正常系：{期待される動作}', () => {
      // Arrange: テストデータの準備
      const input = { /* ... */ };
      const expected = { /* ... */ };

      // Act: 関数実行
      const actual = 対象関数(input);

      // Assert: 結果検証
      expect(actual).toEqual(expected);
    });

    it('異常系：{エラーケースの説明}', () => {
      // エラーケースのテスト
      expect(() => 対象関数(invalidInput)).toThrow('Expected error');
    });

    it('境界値：{境界値テストの説明}', () => {
      // 境界値テスト
    });
  });
});
```

### 3.3 テスト作成の原則（@tdd-guidelines 準拠）

- **AAA パターン**：Arrange-Act-Assert を明確に分離
- **依存注入**：外部依存はモック化し、コンストラクタまたは引数で注入
- **命名**：日本語で「条件のとき結果を返す」形式
- **カバレッジ**：正常系・異常系・境界値を網羅
- **モック最小化**：ビジネスロジックはモックせず、外部依存のみモック
- **型安全性**：`any` を避け、適切な型アサーション（`as`）を使用

### 3.4 モックの作成例

```typescript
// 外部API・DBのモック
jest.mock('../salesforceClient', () => ({
  SalesforceClient: jest.fn().mockImplementation(() => ({
    query: jest.fn().mockResolvedValue({ records: [] }),
    create: jest.fn().mockResolvedValue({ id: 'test-id', success: true }),
  })),
}));

// Slack APIのモック
const mockAck = jest.fn().mockResolvedValue(undefined);
const mockSay = jest.fn().mockResolvedValue(undefined);
const mockClient = {
  views: {
    open: jest.fn().mockResolvedValue({ ok: true }),
    update: jest.fn().mockResolvedValue({ ok: true }),
  },
} as unknown as WebClient;
```

## 4. テストの実行と検証

各ファイルのテスト作成後、以下を確認：

```bash
# 特定ファイルのテストのみ実行
npx jest path/to/__tests__/filename.test.ts --coverage

# 全テスト実行
npx jest --coverage --silent
```

カバレッジが目標に達しているか確認：
- ✅ ビジネスロジック：90%以上
- ✅ ユーティリティ：80%以上
- ✅ プロジェクト全体：70%以上

## 5. カバレッジ改善の繰り返し

目標に達していない場合：

1. カバーされていない行番号を確認（レポートの `Uncovered Line #s` 列）
2. その行に対応するテストケースを追加
3. 再度カバレッジ測定
4. 目標達成まで 1-3 を繰り返す

## 6. テスト品質のチェックリスト

作成したテストが以下の基準を満たしているか確認：

- [ ] すべてのテストが成功する
- [ ] 正常系・異常系・境界値がカバーされている
- [ ] テスト名が日本語で明確に意図を表している
- [ ] AAA パターンに従っている
- [ ] 外部依存が適切にモック化されている
- [ ] 1テストケース1アサーションが基本（複数必要な場合は明確な理由がある）
- [ ] テストが独立している（他のテストに依存しない）
- [ ] テストデータが意味のある値を使っている（`test1`, `user1` などを避ける）

## 7. 作成したテストのドキュメント化

カバレッジ改善作業の記録を残す：

```markdown
## カバレッジ改善記録

### 改善前
- 全体カバレッジ: {XX}%
- 主な未カバーファイル: {リスト}

### 実施内容
- {ファイル名}: {追加したテストケース数}件、カバレッジ {XX}% → {YY}%
- {ファイル名}: {追加したテストケース数}件、カバレッジ {XX}% → {YY}%

### 改善後
- 全体カバレッジ: {YY}%
- 目標達成状況: {達成 / 未達成}

### 残課題
- {未対応の項目があれば記載}
```

## 8. 実行ポリシー

- **段階的に実行**：1ファイルずつテストを作成し、動作確認してから次へ進む
- **優先順位を守る**：ビジネスロジックから順に対応
- **品質重視**：カバレッジ率だけでなく、テストの質を重視
- **リファクタリング**：テストが書きにくい場合は、実装コードの設計を見直す
- **継続的改善**：一度で完璧を目指さず、段階的にカバレッジを向上させる

## 9. 出力形式

各ファイルのテスト作成完了時に以下を出力：

```
✅ {ファイル名} のテスト作成完了
   - テストケース数: {XX}件
   - カバレッジ: {XX}% → {YY}%
   - 実行時間: {X.XX}秒
```

全体完了時：

```
🎉 カバレッジ改善完了

【改善前】
全体: {XX}%

【改善後】
全体: {YY}%
ビジネスロジック: {ZZ}%

【目標達成状況】
✅ プロジェクト全体 70%以上: {達成 / 未達成}
✅ ビジネスロジック 90%以上: {達成 / 未達成}

【作成したテストファイル】
- {リスト}
```

## 10. トラブルシューティング

### テストが失敗する場合
1. 実装コードのバグの可能性を確認
2. モックの設定が正しいか確認
3. 非同期処理の `await` 漏れを確認
4. 型アサーションが適切か確認

### カバレッジが上がらない場合
1. カバーされていない行番号を確認
2. その行が実行される条件を分析
3. 条件を満たすテストケースを追加
4. 到達不能なコード（デッドコード）の可能性を検討

### テストが書きにくい場合
1. 関数が大きすぎないか確認（10-15行を超えていないか）
2. 外部依存が適切に注入されているか確認
3. 純粋関数として切り出せる部分がないか検討
4. 設計のリファクタリングを検討

